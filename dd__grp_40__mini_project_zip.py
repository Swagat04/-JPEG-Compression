# -*- coding: utf-8 -*-
"""DD_<Grp 40>_Mini_Project.zip.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UNtsv9Xewu_nQQsQqLbPin8TDKEw9Va3

Instructions for MINI PROJECT:

1. Topic- JPEG Compression
2. Entire JPEG pipeline must be designed.
"""

import numpy as np
import cv2 as cv
import math
from math import ceil

img = cv.imread("/content/lena_colored_256.bmp",cv.IMREAD_COLOR)
# convert BGR to YCrCb
#img = cv.cvtColor(Original, cv.COLOR_BGR2YCR_CB)

row , col , m = img.shape

#padding
padr = ceil(row/8)*8
padc = ceil(col/8)*8

Y = np.zeros((padr, padc), np.float32) 
cr = np.zeros((padr, padc), np.float32) 
cb = np.zeros((padr, padc), np.float32)

for i in range(row):
  for j in range(col):
    Y[i,j] = 0.299*img[i,j,0] + 0.587*img[i,j,1] + 0.114*img[i,j,2]
    cr[i,j] = -0.169*img[i,j,0] -0.331*img[i,j,1] -0.5*img[i,j,2] + 128
    cb[i,j] = 0.5*img[i,j,0] - 0.419*img[i,j,1] - 0.081*img[i,j,2] + 128

print(row,padr,col,padc)
Y = Y - 128
cr = cr - 128
cb = cb - 128

row = padr
col = padc

#padding code
c= np.array([[ 0.354,  0.354,  0.354,  0.354,  0.354,  0.354,  0.354,  0.354],
 [ 0.49,   0.416,  0.278,  0.098, -0.098, -0.278, -0.416, -0.49 ],
 [ 0.462,  0.191, -0.191, -0.462, -0.462, -0.191 , 0.191,  0.462],
 [ 0.416, -0.098, -0.49,  -0.278,  0.278,  0.49,   0.098, -0.416],
 [ 0.354, -0.354, -0.354,  0.354,  0.354, -0.354, -0.354,  0.354],
 [ 0.278, -0.49,   0.098,  0.416, -0.416, -0.098,  0.49,  -0.278],
 [ 0.191, -0.462,  0.462, -0.191, -0.191,  0.462, -0.462,  0.191],
 [ 0.098, -0.278,  0.416, -0.49,   0.49,  -0.416,  0.278, -0.098]])

c_t = c.transpose()
QTY = np.array([[16, 11, 10, 16, 24, 40, 51, 61],  # luminance quantization table
                [12, 12, 14, 19, 26, 48, 60, 55],
                [14, 13, 16, 24, 40, 57, 69, 56],
                [14, 17, 22, 29, 51, 87, 80, 62],
                [18, 22, 37, 56, 68, 109, 103, 77],
                [24, 35, 55, 64, 81, 104, 113, 92],
                [49, 64, 78, 87, 103, 121, 120, 101],
                [72, 92, 95, 98, 112, 100, 103, 99]])
# 8 block dct 
QTC = np.array([[17, 18, 24, 47, 99, 99, 99, 99],  # chrominance quantization table
                [18, 21, 26, 66, 99, 99, 99, 99],
                [24, 26, 56, 99, 99, 99, 99, 99],
                [47, 66, 99, 99, 99, 99, 99, 99],
                [99, 99, 99, 99, 99, 99, 99, 99],
                [99, 99, 99, 99, 99, 99, 99, 99],
                [99, 99, 99, 99, 99, 99, 99, 99],
                [99, 99, 99, 99, 99, 99, 99, 99]])

F_Y = np.zeros((row,col),dtype = np.float32)
F_Cb = np.zeros((row,col),dtype = np.float32)
F_Cr = np.zeros((row,col),dtype = np.float32)

#DCT CODE
def DCT(Y,F):
    for colitr in range (int(col/8)):
      start_col = 8*colitr
      #print(start_col)
      for rowitr in range (int(row/8)):
        start_row = 8*rowitr
        m = Y[start_row:start_row+8,start_col:start_col+8]@c_t
        dct = c@m
        F[start_row:start_row+8,start_col:start_col+8] = dct

    return F

F_Y = DCT(Y,F_Y)
F_Cb = DCT(cb,F_Cb)
F_Cr = DCT(cr,F_Cr)

#Quantized coefficients
def Quantize(F,QT):
  for colitr in range(int(col/8)):
    start_col = 8*colitr
    for rowitr in range(int(row/8)):
      start_row = 8*rowitr
      F[start_row:start_row+8,start_col:start_col+8] = np.ceil(F[start_row:start_row+8,start_col:start_col+8]/QT)
      return F

QF_Y = Quantize(F_Y,QTY)
QF_Cr = Quantize(F_Cr,QTC)
QF_Cb = Quantize(F_Cb,QTC)

# zigzag ordering
def zigzag(F):
  zigzag = list()

  for rowitr in range(int(row/8)):
    block_x = 8*rowitr
    for colitr in range(int(col/8)):
      block_y = 8*colitr
      count = 1
      after_eight = 0
      next_start_row = 0
      next_start_col = 0
      rev = 0

      while next_start_row < 8 and next_start_col < 8:
        i = 0
        start_row = next_start_row
        start_col = next_start_col
        
        temp = []
        
        while i != count:
          temp.append(F[block_x+start_row-i][block_y+start_col+i])
          
          i = i+1
        if start_row == 7:
          next_start_col = start_col + 1
        else:
          next_start_row = start_row + 1

        if after_eight == 1 : 
          count = count - 1
        else: 
          count = count + 1
        if count == 8:
          after_eight = 1

        if rev == 1:
          temp.reverse()
          #print(temp)
          rev = 0
        else:
          #print(temp)
          rev = 1

        
        zigzag = zigzag + temp

  zigzag = np.array(zigzag)
  zigzag = zigzag.astype(np.int16)  #for getting integer values
  return zigzag

Y_zigzag = zigzag(QF_Y)
Cb_zigzag = zigzag(QF_Cb)
Cr_zigzag = zigzag(QF_Cr)

#runlength encoding
def encode(zigzag):
  encoded = list()
  run_length = 0
  end = ("END",)
  
  block_done=0
  prev_dc = zigzag[0]
  for j in range(len(zigzag)):
              
              
              if  block_done == 0:  # for the first DC component
                  if j == 0:
                    encoded.append((int(zigzag[j]).bit_length(),))
                    
                  else:
                  
                        diff = int(zigzag[j] - prev_dc)
                        if diff != 0:
                            encoded.append((diff.bit_length(),))
                        else:
                            encoded.append((1, diff))
                  prev_dc = zigzag[j]
                  run_length = 0
                  

              else:
              
                  if zigzag[j] == 0:  # increment run_length by one in case of a zero
                      if run_length == 15:
                        encoded.append((run_length, int(zigzag[j]).bit_length(), zigzag[j]))
                        run_length = 0
                      else:
                          run_length += 1
                  else:  # intermediary steam representation of the AC components
                      encoded.append((run_length, int(zigzag[j]).bit_length(), zigzag[j]))
                      run_length = 0
              if block_done == 63:

                encoded.append(end)
                block_done = 0 
              else:
                block_done+=1


              
              # send EOB
              
  if not (encoded[len(encoded) - 1] == end):
                encoded.append(end)
  return encoded

y_encoded = encode(Y_zigzag)
cb_encoded = encode(Cb_zigzag)
cr_encoded = encode(Cr_zigzag)

#print(encoded)
import collections


huffmann_y = collections.defaultdict(int)
huffmann_cb = collections.defaultdict(int)
huffmann_cr = collections.defaultdict(int)

#calculating the frequency
def Frequency(encoded):
  Output = collections.defaultdict(int)
  for elem in encoded:
        
          Output[elem[0:2]] += 1
        
  return Output
  
Freq_y = Frequency(y_encoded)
Freq_cb = Frequency(cb_encoded)
Freq_cr = Frequency(cr_encoded)
 
print(y_encoded)
print(Freq_y)

import scipy
from scipy import fftpack
import matplotlib.pyplot as plt

x = np.zeros((row,col))
y = np.zeros((row,col))
z = np.zeros((row,col))
for colitr in range(int(col/8)):
    start_col = 8*colitr
    for rowitr in range(int(row/8)):
      start_row = 8*rowitr
      x[start_row:start_row+8,start_col:start_col+8] =  scipy.fftpack.idct( scipy.fftpack.idct( QF_Y[start_row:start_row+8,start_col:start_col+8], axis=0, norm='ortho' ), axis=1, norm='ortho' )
      y[start_row:start_row+8,start_col:start_col+8] =  scipy.fftpack.idct( scipy.fftpack.idct( QF_Cb[start_row:start_row+8,start_col:start_col+8], axis=0, norm='ortho' ), axis=1, norm='ortho' )
      z[start_row:start_row+8,start_col:start_col+8] =  scipy.fftpack.idct( scipy.fftpack.idct( QF_Cr[start_row:start_row+8,start_col:start_col+8], axis=0, norm='ortho' ), axis=1, norm='ortho' )
x = x + 128
y = y+128
plt.imshow(x)

# A Huffman Tree Node
import heapq

class node:
	def __init__(self, freq, symbol, left=None, right=None):
		# frequency of symbol
		self.freq = freq

		# symbol name (character)
		self.symbol = symbol

		# node left of current node
		self.left = left

		# node right of current node
		self.right = right

		# tree direction (0/1)
		self.huff = ''
		
	def __lt__(self, nxt):
		return self.freq < nxt.freq
		

# utility function to print huffman
# codes for all symbols in the newly
# created Huffman tree

def huffmann(a):
  huffmann_codes = collections.defaultdict(int) #we consider the default dictionary

  def getCodes(node, val=''):
    
    # huffman code for current node
    newVal = val + str(node.huff)

    # if node is not an edge node
    # then traverse inside it
    if(node.left):
      getCodes(node.left, newVal)
    if(node.right):
      getCodes(node.right, newVal)

      # if node is edge node then
      # display its huffman code
    if(not node.left and not node.right):
                      huffmann_codes[node.symbol] = newVal
                      
                      #print(f"{node.symbol} -> {newVal}")
                              





  # list containing unused nodes
  nodes = []

  # converting characters and frequencies
  # into huffman tree nodes
  for k in a:
    heapq.heappush(nodes, node(a[k], k[0:2]))
    


  #Creating Huffman Tree 
  while len(nodes) > 1:
    
    # sort all the nodes in ascending order
    # based on their frequency
    left = heapq.heappop(nodes)
    right = heapq.heappop(nodes)

    # assign directional value to these nodes
    left.huff = 0
    right.huff = 1

    # combine the 2 smallest nodes to create
    # new node as their parent
    newNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right)

    heapq.heappush(nodes, newNode)


  getCodes(nodes[0])
  return huffmann_codes
  #print(huffmann_codes)
huffmann_y = huffmann(Freq_y)
huffmann_cb = huffmann(Freq_cb)
huffmann_cr = huffmann(Freq_cr)

#compressing the data
def compress_data(encoded,huffmann_codes):
  i= 0 
  compress = str()
  for elem in encoded:
    if i == len(encoded) - 1:
      break
    if len(elem) <=2 :
      compress+=huffmann_codes[elem]
      i +=1
    else:
      st = bin(elem[2])

      if elem[2] < 0:
        for i in range(len(st)):
          if st[i] == "0" :
            st = st[0:i]+"1"+st[i+1:]
          else: st = st[0:i]+"0"+st[i+1:]
        compress+=huffmann_codes[elem[0:2]] + st[3:]
        

      else:
        compress+=huffmann_codes[elem[0:2]] + st[2:]
      i+=1

  
  return compress

    
y_compressed = compress_data(y_encoded,huffmann_y)
cb_compressed = compress_data(cb_encoded,huffmann_cb)
cr_compressed = compress_data(cr_encoded,huffmann_cr)

def Inbytes(compress):
  y = len(compress)%8
  if y!=0:
    compress += "0"*(8-y)

  Byte = bytes()
  num=0
  for i in range(0, len(compress) - 1, 8):
          num = int(compress[i:i+8],base=2)
        
          chr = num.to_bytes(1, 'little')
          Byte += chr
  return Byte

Byte_qy = bytes()

Byte_qc = bytes()

for i in range(8):
  for j in range(8):
    Byte_qy += str(QTY[i,j]).encode()
    Byte_qc += str(QTC[i,j]).encode()
           
        
        
bytedata = bytes()

bytedata+=Inbytes(y_compressed)
bytedata+=Inbytes(cb_compressed)
bytedata+=Inbytes(cr_compressed)

huffmann_tables = bytes()
huffmann_tables = str(huffmann_y).encode() + str(huffmann_cb).encode() + str(huffmann_cr).encode()
bytedata = b'\xFFD8'+ b'\xFFC0'+ str((row,col)).encode()+ b'\xFFDB' + Byte_qy + b'\xFFDB' + Byte_qc + b'\xFFC4' + huffmann_tables  + b'\x00' +bytedata + b'\xFFD9'
print(bytedata)
with open('file.txt','wb') as data: 
      data.write(bytedata)

